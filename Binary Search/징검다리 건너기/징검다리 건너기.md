# 징검다리 건너기
## 문제 풀이 방향
처음 풀었을 때도 슬라이딩 윈도우 방식으로 풀어서 효율성을 통과하지 못했었다. 다시 풀었을 때도 같은 방식을 떠올렸다. 

슬라이딩 윈도우 방식이 느린 이유가 뭘까?
1. stones 배열의 길이가 아주 길 때, 모든 값을 탐색해야한다.
2. 탐색하는 과정에서 양 끝 값을 더하고 빼주어 구간합을 유지하고, 구간 중 최댓값을 구하는 등의 처리 과정이 필요하다.
3. 찾아보니 heapq 자료구조를 사용하면 슬라이딩 윈도우로도 풀이가 가능하다. heqppush와 heappop은 O(logN)의 시간복잡도를 가진다. 
 
반면, Binary Search의 경우 
1. 범위가 정해져있어야 하고 값들이 정렬되어 있어야 한다. 1 ~ 200,000,000 라는 범위가 있고 정렬된 셈이다.
2. 범위 내 값을 반씩 줄여나간다.
3. stones 배열을 쭉 탐색하다가 조건에 만족하지 않으면 바로 break 한다. 



## 공부해야할 부분

- Binary Search와 Two Pointer 차이
  - 이진탐색은 값이 정렬되어 있어야 하지만 투포인터는 정렬되지 않은 상태여도 된다.
  - 이진탐색은 mid를 사용하여 값을 반씩 줄여나가 목표값을 찾는다. O(logN)
  - 투포인터는 양 끝에서부터 포인터를 이동하여 목표값을 찾는다. O(N)


## 참고 
- https://www.acmicpc.net/blog/view/109
- https://leetcode.com/problems/sliding-window-maximum/
